<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>JourneyMapper Pro - Flow Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        glass: 'rgba(15, 23, 42, 0.95)',
                        action: '#3b82f6',
                        debug: '#a855f7',
                        condition: '#f59e0b',
                        switch: '#ec4899',
                        success: '#10b981',
                        error: '#ef4444'
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono&display=swap');

        body {
            background-color: #020617;
            color: #f8fafc;
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        .node {
            background: rgba(30, 41, 59, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.1s;
            z-index: 10;
        }

        .node:hover {
            border-color: rgba(255, 255, 255, 0.3);
            z-index: 20;
        }

        .node-selected {
            border-color: #3b82f6 !important;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4), 0 10px 30px rgba(0,0,0,0.5);
            z-index: 30;
        }

        .node-dragging {
            cursor: grabbing !important;
            transform: scale(1.05);
            opacity: 0.9;
            z-index: 40;
        }

        /* Handles / Ports */
        .handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #64748b;
            border: 2px solid #1e293b;
            border-radius: 50%;
            z-index: 50;
            transition: transform 0.2s, background-color 0.2s;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.3);
        }
        .handle:hover { transform: scale(1.3); border-color: white; }
        
        .handle-in { left: -5px; top: 50%; transform: translateY(-50%); }
        .handle-out { right: -5px; top: 50%; transform: translateY(-50%); }
        
        /* Condition Specific Handles */
        .handle-true { right: -5px; top: 30%; transform: translateY(-50%); background-color: #10b981; }
        .handle-false { right: -5px; top: 70%; transform: translateY(-50%); background-color: #ef4444; }

        /* Switch Specific Handles */
        .handle-opt-a { right: -5px; top: 20%; transform: translateY(-50%); background-color: #f472b6; }
        .handle-opt-b { right: -5px; top: 50%; transform: translateY(-50%); background-color: #c084fc; }
        .handle-opt-c { right: -5px; top: 80%; transform: translateY(-50%); background-color: #60a5fa; }

        /* Edges */
        #world {
            position: absolute;
            width: 5000px;
            height: 5000px;
            background-size: 40px 40px;
            background-image: 
                linear-gradient(to right, rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,255,255,0.03) 1px, transparent 1px);
            transform-origin: 0 0;
        }

        svg#connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .path {
            fill: none;
            stroke-width: 2px;
            stroke: rgba(255,255,255,0.15);
            transition: stroke 0.4s;
        }

        /* Specific Path Colors */
        .path-true { stroke: rgba(16, 185, 129, 0.5); }
        .path-false { stroke: rgba(239, 68, 68, 0.5); }
        .path-opt-a { stroke: rgba(244, 114, 182, 0.5); }
        .path-opt-b { stroke: rgba(192, 132, 252, 0.5); }
        .path-opt-c { stroke: rgba(96, 165, 250, 0.5); }

        .path-active {
            stroke: #3b82f6;
            stroke-width: 3px;
            stroke-dasharray: 8, 8;
            animation: flow 0.8s linear infinite;
        }
        
        .path-active.path-true { stroke: #10b981; }
        .path-active.path-false { stroke: #ef4444; }
        .path-active.path-opt-a { stroke: #f472b6; }
        .path-active.path-opt-b { stroke: #c084fc; }
        .path-active.path-opt-c { stroke: #60a5fa; }

        @keyframes flow { to { stroke-dashoffset: -16; } }

        /* Form Controls */
        .input-glass {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            width: 100%;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }
        .input-glass:focus {
            border-color: #3b82f6;
            background: rgba(0, 0, 0, 0.5);
        }
        
        /* Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.3); }
    </style>
</head>
<body>

    <!-- Header UI -->
    <nav class="fixed top-0 left-0 w-full z-50 p-4 pointer-events-none">
        <div class="glass-panel max-w-6xl mx-auto rounded-full px-4 py-2 flex items-center justify-between pointer-events-auto shadow-2xl">
            <div class="flex items-center gap-4">
                <div class="w-9 h-9 rounded-lg bg-gradient-to-br from-blue-600 to-indigo-700 flex items-center justify-center font-bold shadow-lg shadow-blue-500/20 text-white text-sm">JM</div>
                <div class="hidden sm:block">
                    <h1 class="font-bold text-sm tracking-tight text-white">JourneyMapper <span class="text-blue-400">EDITOR</span></h1>
                </div>
            </div>

            <div class="flex items-center gap-3">
                <div class="hidden md:flex gap-4 border-r border-white/10 pr-4 mr-2">
                    <div class="text-center">
                        <div class="text-[9px] text-slate-400 uppercase font-bold tracking-widest">Nodes</div>
                        <div id="stat-nodes" class="text-white font-bold text-xs">0</div>
                    </div>
                </div>

                <button onclick="addNode()" class="bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-full text-xs font-bold transition-all flex items-center gap-2 border border-white/5">
                    <span class="text-emerald-400 text-lg leading-none">+</span> Add Step
                </button>

                <button id="run-btn" onclick="executeSequence()" class="bg-blue-600 hover:bg-blue-500 text-white px-5 py-2 rounded-full text-xs font-bold transition-all shadow-lg shadow-blue-600/20 flex items-center gap-2 active:scale-95">
                    <span id="run-icon">‚ñ∂</span> Run Flow
                </button>
            </div>
        </div>
    </nav>

    <!-- Canvas -->
    <div id="viewport" class="w-screen h-screen overflow-hidden bg-[#0f172a]">
        <div id="world">
            <svg id="connections"></svg>
            <div id="nodes-layer" class="relative w-full h-full"></div>
        </div>
        
        <!-- Controls Hint -->
        <div class="fixed bottom-6 left-6 text-xs text-slate-500 font-medium pointer-events-none opacity-50">
            Drag to move ‚Ä¢ Click to edit ‚Ä¢ Wheel to pan
        </div>
    </div>

    <!-- Edit Panel -->
    <aside id="inspector" class="fixed top-24 right-4 bottom-6 w-[340px] glass-panel rounded-2xl p-0 z-50 translate-x-[120%] transition-transform duration-300 ease-out flex flex-col overflow-hidden shadow-2xl ring-1 ring-white/10">
        <!-- Header -->
        <div class="p-5 border-b border-white/5 flex justify-between items-center bg-white/5">
            <div class="flex items-center gap-3">
                <div id="inspect-icon-preview" class="w-8 h-8 rounded-lg bg-slate-800 flex items-center justify-center text-lg"></div>
                <h2 class="text-sm font-bold text-white">Edit Node</h2>
            </div>
            <button onclick="closeInspector()" class="w-7 h-7 flex items-center justify-center rounded-full hover:bg-white/10 text-slate-400 hover:text-white transition-colors">‚úï</button>
        </div>
        
        <!-- Scrollable Form -->
        <div id="inspect-content" class="flex-1 overflow-y-auto custom-scrollbar p-5 space-y-6">
            <!-- Dynamic Form Content -->
        </div>

        <!-- Footer Actions -->
        <div class="p-4 border-t border-white/5 bg-black/20 flex gap-2">
            <button onclick="deleteSelectedNode()" class="flex-1 bg-red-500/10 hover:bg-red-500/20 text-red-400 border border-red-500/20 py-2 rounded-lg text-xs font-bold transition-colors">Delete</button>
            <button onclick="closeInspector()" class="flex-1 bg-white/5 hover:bg-white/10 text-slate-300 border border-white/5 py-2 rounded-lg text-xs font-bold transition-colors">Done</button>
        </div>
    </aside>

    <script>
        // --- Configuration & State ---

        const NODE_TYPES = {
            PAGE: { color: 'text-blue-400', bg: 'bg-blue-500/10', border: 'border-blue-500/20', icon: 'üìÑ', label: 'Page View' },
            ACTION: { color: 'text-purple-400', bg: 'bg-purple-500/10', border: 'border-purple-500/20', icon: '‚ö°', label: 'User Action' },
            DEBUG: { color: 'text-indigo-400', bg: 'bg-indigo-500/10', border: 'border-indigo-500/20', icon: 'üîç', label: 'Assertion' },
            CONDITION: { color: 'text-amber-400', bg: 'bg-amber-500/10', border: 'border-amber-500/20', icon: '‚öñÔ∏è', label: 'Condition' },
            SWITCH: { color: 'text-pink-400', bg: 'bg-pink-500/10', border: 'border-pink-500/20', icon: 'üîÄ', label: 'Splitter' },
            SYSTEM: { color: 'text-emerald-400', bg: 'bg-emerald-500/10', border: 'border-emerald-500/20', icon: '‚öôÔ∏è', label: 'System Op' }
        };

        const state = {
            nodes: [
                { id: 'n1', label: 'Login Screen', type: 'PAGE', x: 100, y: 300, icon: 'üè†', details: '/auth/login' },
                { id: 'n2', label: 'Enter Credentials', type: 'ACTION', x: 380, y: 300, icon: '‚å®Ô∏è', action: 'Input' },
                { id: 'n3', label: 'Submit Form', type: 'ACTION', x: 660, y: 300, icon: 'üñ±Ô∏è', action: 'Click' },
                { id: 'n4', label: 'Auth Success?', type: 'CONDITION', x: 940, y: 300, icon: '‚ùì', check: 'HTTP 200' },
                { id: 'n5', label: 'User Type?', type: 'SWITCH', x: 1250, y: 150, icon: 'üîÄ', details: 'Role Check' },
                { id: 'n6', label: 'Admin Panel', type: 'PAGE', x: 1600, y: 50, icon: 'üõ°Ô∏è', details: '/admin' },
                { id: 'n7', label: 'User Home', type: 'PAGE', x: 1600, y: 150, icon: 'üë§', details: '/home' },
                { id: 'n8', label: 'Guest View', type: 'PAGE', x: 1600, y: 250, icon: 'üëÄ', details: '/guest' },
                { id: 'n9', label: 'Show Error', type: 'PAGE', x: 1250, y: 450, icon: '‚ö†Ô∏è', details: 'Alert Modal' }
            ],
            edges: [
                { id: 'e1', from: 'n1', to: 'n2', type: 'default' },
                { id: 'e2', from: 'n2', to: 'n3', type: 'default' },
                { id: 'e3', from: 'n3', to: 'n4', type: 'default' },
                { id: 'e4', from: 'n4', to: 'n5', type: 'true' }, // Auth Success -> Splitter
                { id: 'e5', from: 'n4', to: 'n9', type: 'false' }, // Auth Fail -> Error
                { id: 'e6', from: 'n5', to: 'n6', type: 'opt-a' },
                { id: 'e7', from: 'n5', to: 'n7', type: 'opt-b' },
                { id: 'e8', from: 'n5', to: 'n8', type: 'opt-c' }
            ],
            pan: { x: 50, y: 50 },
            scale: 1,
            isPanning: false,
            draggingNode: null,
            dragOffset: { x: 0, y: 0 },
            activeNodeId: null,
            executing: false,
            activePaths: new Set(),
            completedNodes: new Set()
        };

        // --- DOM Elements ---
        const nodesLayer = document.getElementById('nodes-layer');
        const svgLayer = document.getElementById('connections');
        const world = document.getElementById('world');
        const inspector = document.getElementById('inspector');

        // --- Initialization ---
        function init() {
            render();
            setupInteractions();
            updateStats();
        }

        // --- Core Rendering ---
        function render() {
            nodesLayer.innerHTML = '';
            
            // 1. Render Nodes
            state.nodes.forEach(node => {
                const config = NODE_TYPES[node.type];
                const isSelected = state.activeNodeId === node.id;
                const isComplete = state.completedNodes.has(node.id);
                
                const div = document.createElement('div');
                div.className = `node absolute w-48 p-3 rounded-xl cursor-grab active:cursor-grabbing select-none group ${isSelected ? 'node-selected' : ''}`;
                div.style.transform = `translate(${node.x}px, ${node.y}px)`;
                div.dataset.id = node.id;

                // Status indicator color
                const statusColor = isComplete ? 'bg-emerald-500' : 'bg-slate-700';

                // Determine handles based on type
                let handles = `<div class="handle handle-in" title="Input"></div>`;
                
                if (node.type === 'CONDITION') {
                    handles += `
                        <div class="handle handle-true" title="True Path"></div>
                        <div class="handle handle-false" title="False Path"></div>
                    `;
                } else if (node.type === 'SWITCH') {
                    handles += `
                        <div class="handle handle-opt-a" title="Option A"></div>
                        <div class="handle handle-opt-b" title="Option B"></div>
                        <div class="handle handle-opt-c" title="Option C"></div>
                    `;
                } else {
                    handles += `<div class="handle handle-out" title="Output"></div>`;
                }

                div.innerHTML = `
                    ${handles}
                    <div class="flex items-start gap-3 pointer-events-none">
                        <div class="w-9 h-9 rounded-lg ${config.bg} flex items-center justify-center text-lg border border-white/5 shadow-inner">
                            ${node.icon}
                        </div>
                        <div class="flex-1 overflow-hidden min-w-0">
                            <div class="text-[9px] font-bold uppercase tracking-widest ${config.color} mb-0.5 truncate">${config.label}</div>
                            <div class="text-xs font-bold text-slate-100 truncate">${node.label}</div>
                            <div class="mt-1.5 flex items-center gap-1.5">
                                <div class="w-1.5 h-1.5 rounded-full ${statusColor} ${isComplete ? 'animate-pulse' : ''}"></div>
                                <span class="text-[9px] text-slate-500 font-mono">${isComplete ? 'DONE' : 'IDLE'}</span>
                            </div>
                        </div>
                    </div>
                `;

                // Mouse Events for Dragging & Selection
                div.addEventListener('mousedown', (e) => startNodeDrag(e, node));
                
                nodesLayer.appendChild(div);
            });

            // 2. Render Edges (Curved Lines)
            renderEdges();
        }

        function renderEdges() {
            svgLayer.innerHTML = '';
            
            // Marker definition for arrowheads
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            defs.innerHTML = `
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="rgba(255,255,255,0.15)" />
                </marker>
                 <marker id="arrowhead-active" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
                </marker>
                <marker id="arrowhead-true" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#10b981" />
                </marker>
                <marker id="arrowhead-false" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#ef4444" />
                </marker>
                 <marker id="arrowhead-opt" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#f472b6" />
                </marker>
            `;
            svgLayer.appendChild(defs);

            state.edges.forEach(edge => {
                const fromNodeEl = document.querySelector(`.node[data-id="${edge.from}"]`);
                const toNodeEl = document.querySelector(`.node[data-id="${edge.to}"]`);
                
                if (!fromNodeEl || !toNodeEl) return;

                // Find Handles
                let sourceHandleClass = '.handle-out';
                if (edge.type === 'true') sourceHandleClass = '.handle-true';
                if (edge.type === 'false') sourceHandleClass = '.handle-false';
                if (edge.type === 'opt-a') sourceHandleClass = '.handle-opt-a';
                if (edge.type === 'opt-b') sourceHandleClass = '.handle-opt-b';
                if (edge.type === 'opt-c') sourceHandleClass = '.handle-opt-c';

                const fromHandle = fromNodeEl.querySelector(sourceHandleClass);
                const toHandle = toNodeEl.querySelector('.handle-in');

                if (!fromHandle || !toHandle) return;

                const fromNode = state.nodes.find(n => n.id === edge.from);
                const toNode = state.nodes.find(n => n.id === edge.to);

                // Exact handle coordinates including offset within node
                const startX = fromNode.x + fromHandle.offsetLeft + 5;
                const startY = fromNode.y + fromHandle.offsetTop + 5;
                const endX = toNode.x + toHandle.offsetLeft + 5;
                const endY = toNode.y + toHandle.offsetTop + 5;

                // --- Smart Bezier Logic ---
                const dist = Math.abs(endX - startX);
                
                // Fine-tuned curvature:
                // Ensure the line travels at least 60px horizontally from the source 
                // before bending, even if the target is close or behind.
                const cpOffset = Math.max(dist * 0.4, 60); 

                const controlPoint1X = startX + cpOffset;
                const controlPoint2X = endX - cpOffset;
                
                // If backtracking (target is to the left), increase vertical control
                // to create a nice loop-around effect if needed, though simple CP x-offset usually handles it.

                const pathD = `M ${startX} ${startY} C ${controlPoint1X} ${startY}, ${controlPoint2X} ${endY}, ${endX} ${endY}`;

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", pathD);
                
                const isActive = state.activePaths.has(edge.id);
                let pathClass = `path path-${edge.type || 'default'}`;
                if (isActive) pathClass += ' path-active';
                
                path.setAttribute("class", pathClass);
                
                // Marker Logic
                let marker = 'arrowhead';
                if (isActive) {
                    if (edge.type === 'true') marker = 'arrowhead-true';
                    else if (edge.type === 'false') marker = 'arrowhead-false';
                    else if (edge.type && edge.type.startsWith('opt-')) marker = 'arrowhead-opt';
                    else marker = 'arrowhead-active';
                }
                path.setAttribute("marker-end", `url(#${marker})`);
                
                svgLayer.appendChild(path);
            });
        }

        // --- Node Operations ---

        function addNode() {
            const id = 'n' + Date.now().toString().slice(-4);
            const viewportX = -state.pan.x + (window.innerWidth / 2) - 100;
            const viewportY = -state.pan.y + (window.innerHeight / 2) - 50;

            const newNode = {
                id: id,
                label: 'New Step',
                type: 'ACTION',
                x: viewportX + (Math.random() * 40),
                y: viewportY + (Math.random() * 40),
                icon: '‚ö°',
                action: 'Click'
            };

            // Auto-link logic
            if (state.activeNodeId) {
                const prevNode = state.nodes.find(n => n.id === state.activeNodeId);
                if (prevNode) {
                    newNode.x = prevNode.x + 280;
                    newNode.y = prevNode.y;
                    
                    let edgeType = 'default';
                    if (prevNode.type === 'CONDITION') edgeType = 'true';
                    if (prevNode.type === 'SWITCH') edgeType = 'opt-a';

                    state.edges.push({
                        id: 'e' + Date.now(),
                        from: state.activeNodeId,
                        to: newNode.id,
                        type: edgeType
                    });
                }
            }

            state.nodes.push(newNode);
            selectNode(newNode);
            render();
            updateStats();
        }

        function deleteSelectedNode() {
            if (!state.activeNodeId) return;
            state.nodes = state.nodes.filter(n => n.id !== state.activeNodeId);
            state.edges = state.edges.filter(e => e.from !== state.activeNodeId && e.to !== state.activeNodeId);
            closeInspector();
            render();
            updateStats();
        }

        function updateNodeData(key, value) {
            if (!state.activeNodeId) return;
            const node = state.nodes.find(n => n.id === state.activeNodeId);
            if (!node) return;

            node[key] = value;
            if (key === 'type') {
                const defaults = NODE_TYPES[value];
                node.icon = defaults.icon;
            }

            render();
            selectNode(node); 
        }

        // --- Interactions (Drag & Drop) ---

        function setupInteractions() {
            const viewport = document.getElementById('viewport');
            let startPan = { x: 0, y: 0 };

            viewport.addEventListener('mousedown', (e) => {
                if (e.target.closest('.node')) return;
                state.isPanning = true;
                startPan = { x: e.clientX - state.pan.x, y: e.clientY - state.pan.y };
                viewport.style.cursor = 'grabbing';
            });

            window.addEventListener('mousemove', (e) => {
                if (state.draggingNode) {
                    const node = state.draggingNode;
                    node.x = e.clientX - state.pan.x - state.dragOffset.x;
                    node.y = e.clientY - state.pan.y - state.dragOffset.y;
                    requestAnimationFrame(render);
                    return;
                }
                if (state.isPanning) {
                    state.pan = { x: e.clientX - startPan.x, y: e.clientY - startPan.y };
                    world.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px)`;
                }
            });

            const stopInteraction = () => {
                state.isPanning = false;
                state.draggingNode = null;
                viewport.style.cursor = 'default';
                document.querySelectorAll('.node-dragging').forEach(el => el.classList.remove('node-dragging'));
            };

            window.addEventListener('mouseup', stopInteraction);
            window.addEventListener('mouseleave', stopInteraction);
        }

        function startNodeDrag(e, node) {
            e.stopPropagation();
            state.draggingNode = node;
            state.dragOffset = {
                x: e.clientX - state.pan.x - node.x,
                y: e.clientY - state.pan.y - node.y
            };
            const el = document.querySelector(`.node[data-id="${node.id}"]`);
            if(el) el.classList.add('node-dragging');
            selectNode(node);
        }

        // --- Inspector UI ---

        function selectNode(node) {
            state.activeNodeId = node.id;
            render();

            const content = document.getElementById('inspect-content');
            const iconPreview = document.getElementById('inspect-icon-preview');
            const config = NODE_TYPES[node.type];

            iconPreview.className = `w-8 h-8 rounded-lg ${config.bg} ${config.color} flex items-center justify-center text-lg transition-colors`;
            iconPreview.innerHTML = node.icon;

            content.innerHTML = `
                <div class="space-y-4">
                    <div class="group">
                        <label class="block text-[10px] uppercase font-bold text-slate-500 mb-1">Node Label</label>
                        <input type="text" value="${node.label}" 
                            oninput="updateNodeData('label', this.value)"
                            class="input-glass focus:ring-1 focus:ring-blue-500/50">
                    </div>

                    <div class="group">
                        <label class="block text-[10px] uppercase font-bold text-slate-500 mb-1">Step Type</label>
                        <select onchange="updateNodeData('type', this.value)" 
                            class="input-glass cursor-pointer appearance-none bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlPSJ3aGl0ZSI+PHBhdGggc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2Utd2lkdGg9IjIiIGQ9Ik0xOSA5bDctNyA3IDdNMjEgMTN2NiIgLz48L3N2Zz4=')]">
                            ${Object.keys(NODE_TYPES).map(type => 
                                `<option value="${type}" ${node.type === type ? 'selected' : ''}>${NODE_TYPES[type].label}</option>`
                            ).join('')}
                        </select>
                    </div>

                    <div class="group">
                        <label class="block text-[10px] uppercase font-bold text-slate-500 mb-1">Icon</label>
                        <input type="text" value="${node.icon}" 
                            oninput="updateNodeData('icon', this.value)"
                            class="input-glass text-center w-12 text-lg">
                    </div>

                    <div class="pt-4 border-t border-white/10 mt-2">
                        <h3 class="text-xs font-bold text-white mb-3">Parameters</h3>
                        ${generateDynamicFields(node)}
                    </div>
                    
                    <div class="pt-4 border-t border-white/10 mt-2">
                         <h3 class="text-xs font-bold text-white mb-3">Connections</h3>
                         <div class="space-y-2 bg-black/20 p-2 rounded-lg max-h-48 overflow-y-auto custom-scrollbar">
                            ${generateConnectionControls(node)}
                         </div>
                    </div>
                </div>
            `;

            inspector.classList.remove('translate-x-[120%]');
        }

        function generateDynamicFields(node) {
            if (node.type === 'PAGE') return `
                <div class="group">
                    <label class="block text-[10px] text-slate-500 mb-1">Page URL</label>
                    <input type="text" value="${node.details || ''}" oninput="updateNodeData('details', this.value)" class="input-glass font-mono text-blue-300">
                </div>
            `;
            if (node.type === 'ACTION') return `
                <div class="space-y-3">
                    <div>
                        <label class="block text-[10px] text-slate-500 mb-1">Action</label>
                        <select onchange="updateNodeData('action', this.value)" class="input-glass">
                            <option ${node.action==='Click'?'selected':''}>Click</option>
                            <option ${node.action==='Input'?'selected':''}>Input</option>
                            <option ${node.action==='Hover'?'selected':''}>Hover</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-[10px] text-slate-500 mb-1">Target</label>
                        <input type="text" value="${node.selector || ''}" oninput="updateNodeData('selector', this.value)" class="input-glass font-mono text-purple-300" placeholder=".btn-primary">
                    </div>
                </div>
            `;
            if (node.type === 'CONDITION') return `
                <div class="group">
                    <label class="block text-[10px] text-slate-500 mb-1">Condition Check</label>
                    <input type="text" value="${node.check || ''}" oninput="updateNodeData('check', this.value)" class="input-glass font-mono text-amber-300">
                </div>
            `;
            if (node.type === 'SWITCH') return `
                <div class="group">
                    <label class="block text-[10px] text-slate-500 mb-1">Split Logic</label>
                    <input type="text" value="${node.details || 'Random 33%'}" oninput="updateNodeData('details', this.value)" class="input-glass font-mono text-pink-300">
                </div>
            `;
            return `<div class="text-xs text-slate-500 italic p-2 text-center">No additional parameters</div>`;
        }

        function generateConnectionControls(currentNode) {
            return state.nodes
                .filter(n => n.id !== currentNode.id)
                .map(targetNode => {
                    const existingEdge = state.edges.find(e => e.from === currentNode.id && e.to === targetNode.id);
                    
                    let options = '';
                    if (currentNode.type === 'CONDITION') {
                        options = `
                            <option value="none">None</option>
                            <option value="true" ${existingEdge?.type === 'true' ? 'selected' : ''}>True Path</option>
                            <option value="false" ${existingEdge?.type === 'false' ? 'selected' : ''}>False Path</option>
                        `;
                    } else if (currentNode.type === 'SWITCH') {
                        options = `
                            <option value="none">None</option>
                            <option value="opt-a" ${existingEdge?.type === 'opt-a' ? 'selected' : ''}>Option A (Top)</option>
                            <option value="opt-b" ${existingEdge?.type === 'opt-b' ? 'selected' : ''}>Option B (Mid)</option>
                            <option value="opt-c" ${existingEdge?.type === 'opt-c' ? 'selected' : ''}>Option C (Bot)</option>
                        `;
                    } else {
                        // Standard Checkbox
                        return `
                             <label class="flex items-center justify-between p-2 rounded hover:bg-white/5 cursor-pointer transition-colors group">
                                <div class="flex items-center gap-2 overflow-hidden">
                                    <span class="text-lg opacity-50 grayscale group-hover:grayscale-0">${targetNode.icon}</span>
                                    <span class="text-xs text-slate-300 truncate w-32">${targetNode.label}</span>
                                </div>
                                <input type="checkbox" ${existingEdge ? 'checked' : ''} 
                                    onchange="updateConnection('${currentNode.id}', '${targetNode.id}', this.checked ? 'default' : 'none')"
                                    class="w-4 h-4 rounded border-gray-600 text-blue-600 focus:ring-blue-500 bg-gray-700">
                            </label>
                        `;
                    }

                    // Render Select for complex types
                    return `
                        <div class="flex items-center justify-between p-2 rounded hover:bg-white/5 transition-colors group">
                            <div class="flex items-center gap-2 overflow-hidden">
                                <span class="text-lg opacity-50 grayscale group-hover:grayscale-0">${targetNode.icon}</span>
                                <span class="text-xs text-slate-300 truncate w-24">${targetNode.label}</span>
                            </div>
                            <select onchange="updateConnection('${currentNode.id}', '${targetNode.id}', this.value)" 
                                class="bg-black border border-white/10 text-[10px] rounded px-1 py-1 text-slate-300 outline-none focus:border-blue-500">
                                ${options}
                            </select>
                        </div>
                    `;
                }).join('');
        }

        function updateConnection(fromId, toId, value) {
            state.edges = state.edges.filter(e => !(e.from === fromId && e.to === toId));

            if (value !== 'none') {
                state.edges.push({
                    id: `e-${fromId}-${toId}-${Date.now()}`,
                    from: fromId,
                    to: toId,
                    type: value
                });
            }
            render();
        }

        function closeInspector() {
            inspector.classList.add('translate-x-[120%]');
        }

        // --- Execution Logic ---

        async function executeSequence() {
            if (state.executing) return;
            state.executing = true;
            state.completedNodes.clear();
            state.activePaths.clear();
            
            const btn = document.getElementById('run-btn');
            btn.innerHTML = `<span class="animate-spin">‚è≥</span> Testing...`;

            // Find start nodes
            const incomingEdges = new Set(state.edges.map(e => e.to));
            let queue = state.nodes.filter(n => !incomingEdges.has(n.id)).map(n => n.id);
            if (queue.length === 0 && state.nodes.length > 0) queue = [state.nodes[0].id];

            while (queue.length > 0) {
                const currentBatch = [...new Set(queue)];
                queue = [];

                render();
                await new Promise(r => setTimeout(r, 600));

                for (const nodeId of currentBatch) {
                    state.completedNodes.add(nodeId);
                    
                    const node = state.nodes.find(n => n.id === nodeId);
                    const outgoing = state.edges.filter(e => e.from === nodeId);
                    
                    if (node.type === 'CONDITION') {
                        // Sim: Random Path
                        const decision = Math.random() > 0.5 ? 'true' : 'false';
                        const chosenEdges = outgoing.filter(e => e.type === decision);
                        const edgesToFollow = chosenEdges.length > 0 ? chosenEdges : outgoing;
                        
                        edgesToFollow.forEach(e => { state.activePaths.add(e.id); queue.push(e.to); });
                    } 
                    else if (node.type === 'SWITCH') {
                         // Sim: Random 1 of 3
                        const opts = ['opt-a', 'opt-b', 'opt-c'];
                        const pick = opts[Math.floor(Math.random() * opts.length)];
                        const chosenEdges = outgoing.filter(e => e.type === pick);
                        const edgesToFollow = chosenEdges.length > 0 ? chosenEdges : outgoing; // Fallback to all if path missing

                         edgesToFollow.forEach(e => { state.activePaths.add(e.id); queue.push(e.to); });
                    }
                    else {
                        outgoing.forEach(e => { state.activePaths.add(e.id); queue.push(e.to); });
                    }
                }

                updateStats();
                render();
                await new Promise(r => setTimeout(r, 500));
                state.activePaths.clear();
            }

            state.executing = false;
            btn.innerHTML = `<span>‚ñ∂</span> Run Flow`;
        }

        function updateStats() {
            document.getElementById('stat-nodes').textContent = state.nodes.length;
        }

        init();
        world.style.transform = `translate(${state.pan.x}px, ${state.pan.y}px)`;

    </script>
</body>
</html>